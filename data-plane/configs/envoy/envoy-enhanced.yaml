# =============================================================================
# Envoy Proxy Configuration - Enhanced
# Features: DNS filtering, request/response logging, credential injection
# =============================================================================

admin:
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 9901

static_resources:
  listeners:
    # =========================================================================
    # DNS Proxy Listener (UDP 53)
    # Filters DNS queries to only allow approved domains
    # =========================================================================
    - name: dns_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 53
          protocol: UDP
      listener_filters:
        - name: envoy.filters.udp_listener.udp_proxy
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig
            stat_prefix: dns
            matcher:
              on_no_match:
                action:
                  name: route
                  typed_config:
                    "@type": type.googleapis.com/envoy.extensions.filters.udp.udp_proxy.v3.Route
                    cluster: dns_upstream
            # DNS filtering is handled by external filter or upstream

    # =========================================================================
    # HTTPS Egress Listener with Full Logging
    # =========================================================================
    - name: egress_https
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8443
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: egress_https
                codec_type: AUTO

                # Access logging - JSON to stdout
                access_log:
                  - name: envoy.access_loggers.stdout
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                      log_format:
                        json_format:
                          timestamp: "%START_TIME%"
                          authority: "%REQ(:AUTHORITY)%"
                          real_domain: "%REQ(X-REAL-DOMAIN)%"
                          path: "%REQ(:PATH)%"
                          method: "%REQ(:METHOD)%"
                          response_code: "%RESPONSE_CODE%"
                          response_flags: "%RESPONSE_FLAGS%"
                          credential_injected: "%REQ(X-CREDENTIAL-INJECTED)%"
                          rate_limited: "%REQ(X-RATE-LIMITED)%"
                          duration_ms: "%DURATION%"
                          bytes_received: "%BYTES_RECEIVED%"
                          bytes_sent: "%BYTES_SENT%"
                          upstream_cluster: "%UPSTREAM_CLUSTER%"
                          user_agent: "%REQ(USER-AGENT)%"
                          downstream_remote_address: "%DOWNSTREAM_REMOTE_ADDRESS%"

                route_config:
                  name: egress_routes
                  virtual_hosts:
                    # ---------------------------------------------------------
                    # GitHub API
                    # ---------------------------------------------------------
                    - name: github_api
                      domains:
                        - "api.github.com"
                        - "api.github.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: github_api
                            timeout: 30s
                          request_headers_to_add:
                            - header:
                                key: "X-Source"
                                value: "ai-devbox"

                    # ---------------------------------------------------------
                    # PyPI - Read only
                    # ---------------------------------------------------------
                    - name: pypi
                      domains:
                        - "pypi.org"
                        - "pypi.org:443"
                        - "files.pythonhosted.org"
                        - "files.pythonhosted.org:443"
                      routes:
                        # Block POST/PUT/DELETE (no uploads)
                        - match:
                            prefix: "/"
                            headers:
                              - name: ":method"
                                string_match:
                                  exact: "POST"
                          direct_response:
                            status: 403
                            body:
                              inline_string: "Upload to PyPI not allowed"
                        - match:
                            prefix: "/"
                            headers:
                              - name: ":method"
                                string_match:
                                  exact: "PUT"
                          direct_response:
                            status: 403
                            body:
                              inline_string: "Upload to PyPI not allowed"
                        # Allow GET
                        - match:
                            prefix: "/"
                          route:
                            cluster: pypi
                            timeout: 60s

                    # ---------------------------------------------------------
                    # HuggingFace
                    # ---------------------------------------------------------
                    - name: huggingface
                      domains:
                        - "huggingface.co"
                        - "huggingface.co:443"
                        - "*.huggingface.co"
                        - "*.huggingface.co:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: huggingface
                            timeout: 300s  # Large model downloads
                            max_stream_duration:
                              max_stream_duration: 600s

                    # ---------------------------------------------------------
                    # OpenAI API
                    # ---------------------------------------------------------
                    - name: openai
                      domains:
                        - "api.openai.com"
                        - "api.openai.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: openai_api
                            timeout: 120s

                    # ---------------------------------------------------------
                    # Anthropic API
                    # ---------------------------------------------------------
                    - name: anthropic
                      domains:
                        - "api.anthropic.com"
                        - "api.anthropic.com:443"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: anthropic_api
                            timeout: 120s

                    # ---------------------------------------------------------
                    # Devbox Local - HTTP to HTTPS upgrade with credentials
                    # Agent uses: curl http://api-openai-com.devbox.local/...
                    # Envoy upgrades to HTTPS and injects credentials
                    # ---------------------------------------------------------
                    - name: devbox_openai
                      domains:
                        - "api-openai-com.devbox.local"
                        - "api-openai-com.devbox.local:*"
                        - "openai.devbox.local"
                        - "openai.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: openai_api
                            timeout: 120s
                            auto_host_rewrite: true

                    - name: devbox_anthropic
                      domains:
                        - "api-anthropic-com.devbox.local"
                        - "api-anthropic-com.devbox.local:*"
                        - "anthropic.devbox.local"
                        - "anthropic.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: anthropic_api
                            timeout: 120s
                            auto_host_rewrite: true

                    - name: devbox_github
                      domains:
                        - "api-github-com.devbox.local"
                        - "api-github-com.devbox.local:*"
                        - "github.devbox.local"
                        - "github.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: github_api
                            timeout: 30s
                            auto_host_rewrite: true

                    - name: devbox_huggingface
                      domains:
                        - "huggingface-co.devbox.local"
                        - "huggingface-co.devbox.local:*"
                        - "huggingface.devbox.local"
                        - "huggingface.devbox.local:*"
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: huggingface
                            timeout: 300s
                            auto_host_rewrite: true

                    # ---------------------------------------------------------
                    # Catch-all - Block with logging
                    # ---------------------------------------------------------
                    - name: blocked
                      domains:
                        - "*"
                      routes:
                        - match:
                            prefix: "/"
                          direct_response:
                            status: 403
                            body:
                              inline_string: '{"error": "destination_not_allowed", "message": "This domain is not in the allowlist"}'

                http_filters:
                  # ---------------------------------------------------------
                  # Request/Response Body Logging (Tap)
                  # ---------------------------------------------------------
                  - name: envoy.filters.http.tap
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.tap.v3.Tap
                      common_config:
                        static_config:
                          match_config:
                            any_match: true
                          output_config:
                            sinks:
                              - file_per_tap:
                                  path_prefix: /var/log/envoy/tap/
                            max_buffered_rx_bytes: 10240  # 10KB request body
                            max_buffered_tx_bytes: 10240  # 10KB response body
                            streaming: false

                  # ---------------------------------------------------------
                  # Lua Filter - Credential Injection + Rate Limiting + Security
                  # ---------------------------------------------------------
                  - name: envoy.filters.http.lua
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                      inline_code: |
                        -- =======================================================================
                        -- Configuration
                        -- =======================================================================
                        -- Mode: "standalone" = no control plane, "connected" = use CP with fallback
                        local DATAPLANE_MODE = os.getenv("DATAPLANE_MODE") or "connected"
                        local API_TOKEN = os.getenv("CONTROL_PLANE_TOKEN") or os.getenv("API_TOKEN") or ""
                        local CACHE_TTL_SECONDS = 300  -- 5 minutes
                        local CP_FAILURE_BACKOFF = 30  -- Seconds to wait before retrying CP after failure

                        -- Caches
                        local credential_cache = {}  -- domain -> {header_name, header_value, expires_at}
                        local rate_limit_cache = {}  -- domain -> {rpm, burst, expires_at}
                        local egress_limit_cache = {}  -- domain -> {bytes_per_hour, expires_at}
                        local domain_policy_cache = {}  -- domain -> {policy, expires_at} (unified cache)
                        local token_buckets = {}     -- domain -> {tokens, last_refill}

                        -- Egress volume tracking (in-memory, resets on restart)
                        -- NOTE: This is not persistent - byte counts reset when Envoy restarts
                        local egress_bytes = {}      -- domain -> {bytes, window_start}
                        local EGRESS_WINDOW_SECONDS = 3600  -- 1 hour window
                        local DEFAULT_EGRESS_LIMIT = 100 * 1024 * 1024  -- 100MB per hour default

                        -- Control plane health tracking
                        local cp_available = true
                        local cp_last_failure = 0

                        -- =======================================================================
                        -- Static Configuration (loaded from environment, for standalone mode)
                        -- Format: STATIC_CREDENTIALS="domain:header_name:header_value[:alias]"
                        --   Example: api.openai.com:Authorization:Bearer sk-xxx:openai
                        --   With alias, openai.devbox.local resolves to api.openai.com
                        -- Format: STATIC_RATE_LIMITS="api.openai.com:60:10,default:120:20"
                        -- =======================================================================
                        local static_credentials = {}  -- domain -> {header_name, header_value, target_domain}
                        local static_alias_map = {}    -- alias.devbox.local -> domain
                        local static_rate_limits = {}
                        local static_egress_limits = {} -- domain -> bytes_per_hour
                        local static_config_loaded = false

                        function load_static_config(request_handle)
                          if static_config_loaded then return end
                          static_config_loaded = true

                          -- Load static credentials (format: domain:header_name:header_value[:alias])
                          local creds_env = os.getenv("STATIC_CREDENTIALS") or ""
                          for cred in string.gmatch(creds_env, "[^|]+") do
                            -- Try to match with optional alias (4 parts)
                            local domain, header_name, header_value, alias = string.match(cred, "([^:]+):([^:]+):([^:]+):([^:]+)")
                            if not domain then
                              -- Fall back to 3-part format (no alias)
                              domain, header_name, header_value = string.match(cred, "([^:]+):([^:]+):(.+)")
                            end
                            if domain and header_name and header_value then
                              static_credentials[domain] = {
                                header_name = header_name,
                                header_value = header_value,
                                target_domain = domain
                              }
                              request_handle:logInfo("Static credential loaded for: " .. domain)
                              -- If alias provided, map alias.devbox.local -> domain
                              if alias then
                                local alias_domain = alias .. ".devbox.local"
                                static_alias_map[alias_domain] = domain
                                request_handle:logInfo("Static alias: " .. alias_domain .. " -> " .. domain)
                              end
                            end
                          end

                          -- Load static rate limits (domain:rpm:burst)
                          local limits_env = os.getenv("STATIC_RATE_LIMITS") or ""
                          for limit in string.gmatch(limits_env, "[^,]+") do
                            local domain, rpm, burst = string.match(limit, "([^:]+):(%d+):(%d+)")
                            if domain and rpm then
                              static_rate_limits[domain] = {
                                requests_per_minute = tonumber(rpm),
                                burst_size = tonumber(burst) or 10
                              }
                              request_handle:logInfo("Static rate limit for " .. domain .. ": " .. rpm .. " rpm")
                            end
                          end

                          -- Default rate limit if not specified
                          if not static_rate_limits["default"] then
                            static_rate_limits["default"] = {
                              requests_per_minute = 120,
                              burst_size = 20
                            }
                          end

                          -- Load static egress limits (domain:bytes_per_hour)
                          -- Example: STATIC_EGRESS_LIMITS="api.openai.com:10485760,default:104857600"
                          local egress_env = os.getenv("STATIC_EGRESS_LIMITS") or ""
                          for limit in string.gmatch(egress_env, "[^,]+") do
                            local domain, bytes = string.match(limit, "([^:]+):(%d+)")
                            if domain and bytes then
                              static_egress_limits[domain] = tonumber(bytes)
                              request_handle:logInfo("Static egress limit for " .. domain .. ": " .. bytes .. " bytes/hour")
                            end
                          end
                        end

                        -- Check if control plane should be contacted
                        function should_contact_cp()
                          if DATAPLANE_MODE == "standalone" then
                            return false
                          end
                          if API_TOKEN == "" then
                            return false
                          end
                          -- Backoff after failure
                          if not cp_available and (os.time() - cp_last_failure) < CP_FAILURE_BACKOFF then
                            return false
                          end
                          return true
                        end

                        -- Mark CP as failed (for backoff)
                        function mark_cp_failure()
                          cp_available = false
                          cp_last_failure = os.time()
                        end

                        -- Mark CP as available
                        function mark_cp_success()
                          cp_available = true
                        end

                        -- Check if host is a devbox.local alias
                        function is_devbox_local(host)
                          local host_clean = string.match(host, "^([^:]+)") or host
                          return string.match(host_clean, "%.devbox%.local$") ~= nil
                        end

                        -- Clean host (remove port)
                        function clean_host(host)
                          return string.match(host, "^([^:]+)") or host
                        end

                        -- DNS Tunneling Detection
                        function detect_dns_tunneling(host)
                          local parts = {}
                          for part in string.gmatch(host, "[^%.]+") do
                            table.insert(parts, part)
                          end

                          for _, part in ipairs(parts) do
                            if string.len(part) > 63 then
                              return true, "Subdomain exceeds 63 characters"
                            end
                          end

                          if string.len(host) > 100 then
                            return true, "Hostname unusually long"
                          end

                          return false, nil
                        end

                        -- URL encode for query params
                        function url_encode(str)
                          if str then
                            str = string.gsub(str, "([^%w%-%.%_%~])", function(c)
                              return string.format("%%%02X", string.byte(c))
                            end)
                          end
                          return str
                        end

                        -- Simple JSON parser for credential response
                        function parse_credential_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local matched = string.match(body, '"matched"%s*:%s*true')
                          if not matched then
                            return nil
                          end

                          local header_name = string.match(body, '"header_name"%s*:%s*"([^"]+)"')
                          local header_value = string.match(body, '"header_value"%s*:%s*"([^"]+)"')
                          local target_domain = string.match(body, '"target_domain"%s*:%s*"([^"]+)"')

                          if header_name and header_value then
                            return {
                              header_name = header_name,
                              header_value = header_value,
                              target_domain = target_domain  -- Real domain for devbox.local aliases
                            }
                          end

                          return nil
                        end

                        -- Parse rate limit response
                        function parse_rate_limit_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local rpm = string.match(body, '"requests_per_minute"%s*:%s*(%d+)')
                          local burst = string.match(body, '"burst_size"%s*:%s*(%d+)')

                          if rpm then
                            return {
                              requests_per_minute = tonumber(rpm),
                              burst_size = tonumber(burst) or 10
                            }
                          end

                          return nil
                        end

                        function parse_egress_limit_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local bytes = string.match(body, '"bytes_per_hour"%s*:%s*(%d+)')

                          if bytes then
                            return {
                              bytes_per_hour = tonumber(bytes)
                            }
                          end

                          return nil
                        end

                        -- Get credential for domain (with caching, static fallback)
                        function get_credential(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          local cached = credential_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached
                          end

                          local cred = nil

                          -- Try control plane first (if available)
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/secrets/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              cred = parse_credential_response(body)
                            else
                              mark_cp_failure()
                              request_handle:logWarn("CP unavailable for credential lookup: " .. host_clean)
                            end
                          end

                          -- Fall back to static credentials
                          if not cred then
                            -- Check if this is a devbox.local alias
                            local lookup_domain = static_alias_map[host_clean] or host_clean
                            cred = static_credentials[lookup_domain]
                            -- If found via alias, ensure target_domain is set
                            if cred and static_alias_map[host_clean] then
                              cred = {
                                header_name = cred.header_name,
                                header_value = cred.header_value,
                                target_domain = lookup_domain
                              }
                            end
                            -- Try wildcard match (*.domain.com)
                            if not cred then
                              for pattern, static_cred in pairs(static_credentials) do
                                if string.sub(pattern, 1, 2) == "*." then
                                  local suffix = string.sub(pattern, 2)  -- .domain.com
                                  if string.sub(lookup_domain, -string.len(suffix)) == suffix then
                                    cred = static_cred
                                    break
                                  end
                                end
                              end
                            end
                          end

                          if cred then
                            cred.expires_at = os.time() + CACHE_TTL_SECONDS
                            credential_cache[host_clean] = cred
                          else
                            -- Cache negative result briefly
                            credential_cache[host_clean] = { expires_at = os.time() + 60 }
                          end

                          return cred
                        end

                        -- Get rate limit config for domain (with caching, static fallback)
                        function get_rate_limit_config(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          local cached = rate_limit_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached
                          end

                          local config = nil

                          -- Try control plane first (if available)
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/rate-limits/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              config = parse_rate_limit_response(body)
                            else
                              mark_cp_failure()
                            end
                          end

                          -- Fall back to static rate limits
                          if not config then
                            config = static_rate_limits[host_clean]
                            -- Try wildcard match
                            if not config then
                              for pattern, static_limit in pairs(static_rate_limits) do
                                if string.sub(pattern, 1, 2) == "*." then
                                  local suffix = string.sub(pattern, 2)
                                  if string.sub(host_clean, -string.len(suffix)) == suffix then
                                    config = static_limit
                                    break
                                  end
                                end
                              end
                            end
                            -- Use default
                            if not config then
                              config = static_rate_limits["default"] or {
                                requests_per_minute = 120,
                                burst_size = 20
                              }
                            end
                          end

                          config.expires_at = os.time() + CACHE_TTL_SECONDS
                          rate_limit_cache[host_clean] = config

                          return config
                        end

                        -- Token bucket rate limiter
                        function check_rate_limit(request_handle, domain)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local config = get_rate_limit_config(request_handle, host_clean)

                          if not config then
                            return true  -- Allow if no config
                          end

                          local now = os.time()
                          local bucket = token_buckets[host_clean]

                          if not bucket then
                            -- Initialize bucket
                            bucket = {
                              tokens = config.burst_size,
                              last_refill = now
                            }
                            token_buckets[host_clean] = bucket
                          end

                          -- Refill tokens based on time elapsed
                          local elapsed = now - bucket.last_refill
                          local tokens_per_second = config.requests_per_minute / 60.0
                          local new_tokens = elapsed * tokens_per_second
                          bucket.tokens = math.min(config.burst_size, bucket.tokens + new_tokens)
                          bucket.last_refill = now

                          -- Try to consume a token
                          if bucket.tokens >= 1 then
                            bucket.tokens = bucket.tokens - 1
                            return true
                          end

                          request_handle:logWarn(string.format(
                            "Rate limit exceeded for %s (limit: %d rpm)",
                            host_clean, config.requests_per_minute
                          ))
                          return false
                        end

                        -- Rate limiter with explicit config (for unified policy)
                        function check_rate_limit_with_config(request_handle, domain, rpm, burst)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local now = os.time()
                          local bucket = token_buckets[host_clean]

                          if not bucket then
                            bucket = {
                              tokens = burst,
                              last_refill = now
                            }
                            token_buckets[host_clean] = bucket
                          end

                          -- Refill tokens
                          local elapsed = now - bucket.last_refill
                          local tokens_per_second = rpm / 60.0
                          local new_tokens = elapsed * tokens_per_second
                          bucket.tokens = math.min(burst, bucket.tokens + new_tokens)
                          bucket.last_refill = now

                          if bucket.tokens >= 1 then
                            bucket.tokens = bucket.tokens - 1
                            return true
                          end

                          request_handle:logWarn(string.format(
                            "Rate limit exceeded for %s (limit: %d rpm)",
                            host_clean, rpm
                          ))
                          return false
                        end

                        -- Egress limit check with explicit config (for unified policy)
                        function check_egress_limit_with_config(request_handle, domain, bytes_limit)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local now = os.time()

                          local tracker = egress_bytes[host_clean]
                          if not tracker then
                            tracker = { bytes = 0, window_start = now }
                            egress_bytes[host_clean] = tracker
                          end

                          -- Reset window if expired
                          if (now - tracker.window_start) >= EGRESS_WINDOW_SECONDS then
                            tracker.bytes = 0
                            tracker.window_start = now
                          end

                          return tracker.bytes < bytes_limit, tracker.bytes
                        end

                        -- Get egress limit for domain (with caching, static fallback) - DEPRECATED
                        function get_egress_limit(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          -- Check cache first
                          local cached = egress_limit_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached.bytes_per_hour
                          end

                          local limit = nil

                          -- Try control plane first (if available)
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/egress-limits/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              local config = parse_egress_limit_response(body)
                              if config then
                                limit = config.bytes_per_hour
                              end
                            else
                              mark_cp_failure()
                            end
                          end

                          -- Fall back to static config
                          if not limit then
                            -- Check domain-specific limit
                            limit = static_egress_limits[host_clean]

                            if not limit then
                              -- Check wildcard
                              for pattern, bytes in pairs(static_egress_limits) do
                                if string.sub(pattern, 1, 2) == "*." then
                                  local suffix = string.sub(pattern, 2)
                                  if string.sub(host_clean, -string.len(suffix)) == suffix then
                                    limit = bytes
                                    break
                                  end
                                end
                              end
                            end

                            -- Use default
                            if not limit then
                              limit = static_egress_limits["default"] or DEFAULT_EGRESS_LIMIT
                            end
                          end

                          -- Cache the result
                          egress_limit_cache[host_clean] = {
                            bytes_per_hour = limit,
                            expires_at = os.time() + CACHE_TTL_SECONDS
                          }

                          return limit
                        end

                        -- Check egress volume limit (returns allowed, current_bytes, limit)
                        function check_egress_limit(request_handle, domain)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local limit = get_egress_limit(request_handle, host_clean)
                          local now = os.time()

                          local tracker = egress_bytes[host_clean]
                          if not tracker then
                            tracker = { bytes = 0, window_start = now }
                            egress_bytes[host_clean] = tracker
                          end

                          -- Reset window if expired
                          if (now - tracker.window_start) >= EGRESS_WINDOW_SECONDS then
                            tracker.bytes = 0
                            tracker.window_start = now
                          end

                          return tracker.bytes < limit, tracker.bytes, limit
                        end

                        -- Record egress bytes (called from response handler)
                        function record_egress_bytes(request_handle, domain, bytes)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local now = os.time()

                          local tracker = egress_bytes[host_clean]
                          if not tracker then
                            tracker = { bytes = 0, window_start = now }
                            egress_bytes[host_clean] = tracker
                          end

                          -- Reset window if expired
                          if (now - tracker.window_start) >= EGRESS_WINDOW_SECONDS then
                            tracker.bytes = 0
                            tracker.window_start = now
                          end

                          tracker.bytes = tracker.bytes + bytes

                          local limit = get_egress_limit(request_handle, host_clean)
                          if tracker.bytes > limit then
                            request_handle:logWarn(string.format(
                              "Egress limit exceeded for %s: %d / %d bytes",
                              host_clean, tracker.bytes, limit
                            ))
                          end
                        end

                        -- =======================================================================
                        -- Unified Domain Policy (single CP call for all policies)
                        -- =======================================================================

                        function get_domain_policy(request_handle, domain)
                          load_static_config(request_handle)
                          local host_clean = string.match(domain, "^([^:]+)") or domain

                          -- Check cache first
                          local cached = domain_policy_cache[host_clean]
                          if cached and cached.expires_at > os.time() then
                            return cached.policy
                          end

                          local policy = nil

                          -- Try control plane first
                          if should_contact_cp() then
                            local headers, body = request_handle:httpCall(
                              "control_plane_api",
                              {
                                [":method"] = "GET",
                                [":path"] = "/api/v1/domain-policies/for-domain?domain=" .. url_encode(host_clean),
                                [":authority"] = "control-plane-api",
                                ["authorization"] = "Bearer " .. API_TOKEN
                              },
                              "",
                              5000,
                              false
                            )

                            if body and string.len(body) > 0 then
                              mark_cp_success()
                              policy = parse_domain_policy_response(body)
                            else
                              mark_cp_failure()
                            end
                          end

                          -- Fall back to static config if no CP response
                          if not policy then
                            policy = build_static_policy(host_clean)
                          end

                          -- Cache the result
                          domain_policy_cache[host_clean] = {
                            policy = policy,
                            expires_at = os.time() + CACHE_TTL_SECONDS
                          }

                          return policy
                        end

                        function parse_domain_policy_response(body)
                          if not body or body == "" then
                            return nil
                          end

                          local policy = {
                            matched = string.match(body, '"matched"%s*:%s*true') ~= nil,
                            allowed_paths = {},
                            requests_per_minute = tonumber(string.match(body, '"requests_per_minute"%s*:%s*(%d+)')) or 120,
                            burst_size = tonumber(string.match(body, '"burst_size"%s*:%s*(%d+)')) or 20,
                            bytes_per_hour = tonumber(string.match(body, '"bytes_per_hour"%s*:%s*(%d+)')) or DEFAULT_EGRESS_LIMIT,
                            credential = nil,
                            target_domain = nil
                          }

                          -- Parse allowed_paths array
                          local paths_str = string.match(body, '"allowed_paths"%s*:%s*%[([^%]]*)%]')
                          if paths_str then
                            for path in string.gmatch(paths_str, '"([^"]+)"') do
                              table.insert(policy.allowed_paths, path)
                            end
                          end

                          -- Parse credential
                          local cred_header = string.match(body, '"header_name"%s*:%s*"([^"]*)"')
                          local cred_value = string.match(body, '"header_value"%s*:%s*"([^"]*)"')
                          local target = string.match(body, '"target_domain"%s*:%s*"([^"]*)"')
                          if cred_header and cred_value then
                            policy.credential = {
                              header_name = cred_header,
                              header_value = cred_value
                            }
                            policy.target_domain = target
                          end

                          -- Parse alias for domain rewriting
                          local alias = string.match(body, '"alias"%s*:%s*"([^"]*)"')
                          if alias then
                            policy.alias = alias
                          end

                          return policy
                        end

                        function build_static_policy(domain)
                          -- Build policy from static config
                          local policy = {
                            matched = false,
                            allowed_paths = {},
                            requests_per_minute = 120,
                            burst_size = 20,
                            bytes_per_hour = DEFAULT_EGRESS_LIMIT,
                            credential = nil,
                            target_domain = nil
                          }

                          -- Check static rate limits
                          local rl = static_rate_limits[domain] or static_rate_limits["default"]
                          if rl then
                            policy.requests_per_minute = rl.requests_per_minute or 120
                            policy.burst_size = rl.burst_size or 20
                            policy.matched = true
                          end

                          -- Check static egress limits
                          local el = static_egress_limits[domain] or static_egress_limits["default"]
                          if el then
                            policy.bytes_per_hour = el
                          end

                          -- Check static credentials
                          local cred = static_credentials[domain]
                          if cred then
                            policy.credential = {
                              header_name = cred.header_name,
                              header_value = cred.header_value
                            }
                            policy.target_domain = cred.target_domain
                            policy.matched = true
                          end

                          return policy
                        end

                        function match_path_pattern(pattern, path)
                          if string.sub(pattern, -2) == "/*" then
                            local prefix = string.sub(pattern, 1, -2)
                            return string.sub(path, 1, string.len(prefix)) == prefix
                          elseif string.sub(pattern, -1) == "*" then
                            local prefix = string.sub(pattern, 1, -2)
                            return string.sub(path, 1, string.len(prefix)) == prefix
                          else
                            return path == pattern
                          end
                        end

                        function is_path_allowed(policy, path)
                          -- No paths defined = all paths allowed
                          if not policy.allowed_paths or #policy.allowed_paths == 0 then
                            return true, "no_restrictions"
                          end

                          -- Check each pattern
                          for _, pattern in ipairs(policy.allowed_paths) do
                            if match_path_pattern(pattern, path) then
                              return true, pattern
                            end
                          end

                          return false, "path_not_in_allowlist"
                        end

                        -- Path allowlist cache: domain:path -> {allowed, expires_at}
                        local path_allowed_cache = {}

                        -- Check if path is allowed for domain (with caching) - DEPRECATED, use get_domain_policy
                        function check_path_allowed(request_handle, domain, path)
                          local host_clean = string.match(domain, "^([^:]+)") or domain
                          local cache_key = host_clean .. ":" .. path

                          -- Check cache first
                          local cached = path_allowed_cache[cache_key]
                          if cached and cached.expires_at > os.time() then
                            return cached.allowed, cached.reason
                          end

                          -- In standalone mode, no path filtering (allow all)
                          if not should_contact_cp() then
                            return true, "standalone_mode"
                          end

                          -- Query control plane
                          local headers, body = request_handle:httpCall(
                            "control_plane_api",
                            {
                              [":method"] = "GET",
                              [":path"] = "/api/v1/allowlist/check-path?domain=" .. url_encode(host_clean) .. "&path=" .. url_encode(path),
                              [":authority"] = "control-plane-api",
                              ["authorization"] = "Bearer " .. API_TOKEN
                            },
                            "",
                            5000,
                            false
                          )

                          local allowed = true
                          local reason = "no_response"

                          if body and string.len(body) > 0 then
                            mark_cp_success()
                            -- Parse response: {"allowed": true/false, "reason": "..."}
                            local allowed_str = string.match(body, '"allowed"%s*:%s*(%w+)')
                            reason = string.match(body, '"reason"%s*:%s*"([^"]*)"') or "unknown"

                            if allowed_str == "false" then
                              allowed = false
                            end
                          else
                            mark_cp_failure()
                            -- On CP failure, allow (fail open for availability)
                            allowed = true
                            reason = "cp_unavailable"
                          end

                          -- Cache the result
                          path_allowed_cache[cache_key] = {
                            allowed = allowed,
                            reason = reason,
                            expires_at = os.time() + CACHE_TTL_SECONDS
                          }

                          return allowed, reason
                        end

                        -- Store domain for response handler
                        local request_domain = nil

                        function envoy_on_request(request_handle)
                          local host = request_handle:headers():get(":authority") or ""
                          local host_clean = clean_host(host)
                          local credential_injected = "false"
                          local rate_limited = "false"
                          local devbox_local = is_devbox_local(host)

                          -- Skip DNS tunneling check for devbox.local (it's internal)
                          if not devbox_local then
                            local is_suspicious, reason = detect_dns_tunneling(host)
                            if is_suspicious then
                              request_handle:logWarn("Potential DNS tunneling: " .. host .. " - " .. reason)
                              request_handle:respond(
                                {[":status"] = "403"},
                                "Request blocked: suspicious hostname pattern"
                              )
                              return
                            end
                          end

                          -- Get unified domain policy (single CP call for all policies)
                          local policy = get_domain_policy(request_handle, host_clean)
                          local real_domain = host_clean
                          if policy and policy.target_domain then
                            real_domain = policy.target_domain
                          end

                          -- Rate limiting using policy
                          local rpm = policy and policy.requests_per_minute or 120
                          local burst = policy and policy.burst_size or 20
                          if not check_rate_limit_with_config(request_handle, real_domain, rpm, burst) then
                            rate_limited = "true"
                            request_handle:headers():add("X-Rate-Limited", rate_limited)
                            request_handle:respond(
                              {[":status"] = "429", ["retry-after"] = "60"},
                              '{"error": "rate_limit_exceeded", "message": "Too many requests to this domain"}'
                            )
                            return
                          end

                          -- Path allowlist check using policy
                          local request_path = request_handle:headers():get(":path") or "/"
                          local path_only = string.match(request_path, "^([^?]+)") or request_path
                          local path_allowed, path_reason = is_path_allowed(policy, path_only)
                          if not path_allowed then
                            request_handle:logWarn(string.format(
                              "Path not allowed: %s%s (reason: %s)",
                              real_domain, path_only, path_reason
                            ))
                            request_handle:respond(
                              {[":status"] = "403"},
                              '{"error": "path_not_allowed", "message": "This path is not in the allowlist for this domain"}'
                            )
                            return
                          end

                          -- Egress volume limit check using policy
                          local bytes_limit = policy and policy.bytes_per_hour or DEFAULT_EGRESS_LIMIT
                          local egress_allowed, current_bytes = check_egress_limit_with_config(request_handle, real_domain, bytes_limit)
                          if not egress_allowed then
                            request_handle:logWarn(string.format(
                              "Egress limit exceeded for %s: %d / %d bytes",
                              real_domain, current_bytes, bytes_limit
                            ))
                            request_handle:respond(
                              {[":status"] = "429", ["retry-after"] = "3600"},
                              '{"error": "egress_limit_exceeded", "message": "Hourly egress limit exceeded for this domain"}'
                            )
                            return
                          end

                          -- Store domain for response handler to track bytes
                          request_domain = real_domain

                          -- Credential injection using policy
                          if policy and policy.credential and policy.credential.header_name and policy.credential.header_value then
                            request_handle:headers():remove(policy.credential.header_name)
                            request_handle:headers():add(policy.credential.header_name, policy.credential.header_value)
                            credential_injected = "true"
                            request_handle:logInfo(string.format(
                              "Injected credential for %s (via %s): %s",
                              real_domain, host, policy.credential.header_name
                            ))
                          end

                          -- Add tracking headers for access log
                          request_handle:headers():add("X-Credential-Injected", credential_injected)
                          request_handle:headers():add("X-Rate-Limited", rate_limited)
                          request_handle:headers():add("X-Real-Domain", real_domain)
                          request_handle:headers():add("X-Devbox-Timestamp", os.date("!%Y-%m-%dT%H:%M:%SZ"))

                          if devbox_local then
                            request_handle:logInfo(string.format(
                              "Devbox proxy: %s -> %s (credential_injected=%s)",
                              host, real_domain, credential_injected
                            ))
                          end
                        end

                        function envoy_on_response(response_handle)
                          local status = response_handle:headers():get(":status")
                          local content_length_str = response_handle:headers():get("content-length") or "0"
                          local content_length = tonumber(content_length_str) or 0

                          -- Track egress bytes for the domain from the request
                          if request_domain and content_length > 0 then
                            record_egress_bytes(response_handle, request_domain, content_length)
                          end

                          response_handle:logInfo(string.format(
                            "RESPONSE: status=%s content_length=%s domain=%s",
                            status, content_length_str, request_domain or "unknown"
                          ))
                        end

                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
    # =========================================================================
    # Control Plane API (for credential lookup)
    # =========================================================================
    - name: control_plane_api
      type: STRICT_DNS
      connect_timeout: 5s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: control_plane_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: control-plane-api
                      port_value: 8002

    # =========================================================================
    # DNS Upstream (Filtered)
    # =========================================================================
    - name: dns_upstream
      type: STRICT_DNS
      connect_timeout: 2s
      lb_policy: ROUND_ROBIN
      load_assignment:
        cluster_name: dns_upstream
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: 8.8.8.8
                      port_value: 53

    # =========================================================================
    # External Service Clusters
    # =========================================================================
    - name: github_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 100
            max_pending_requests: 100
            max_requests: 100
            max_retries: 3
      load_assignment:
        cluster_name: github_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.github.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.github.com

    - name: pypi
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 50
            max_requests: 100
      load_assignment:
        cluster_name: pypi
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: pypi.org
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: pypi.org

    - name: huggingface
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 20
            max_pending_requests: 10
            max_requests: 30
      load_assignment:
        cluster_name: huggingface
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: huggingface.co
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: huggingface.co

    - name: openai_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 100
            max_requests: 60
      load_assignment:
        cluster_name: openai_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.openai.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.openai.com

    - name: anthropic_api
      type: LOGICAL_DNS
      connect_timeout: 10s
      lb_policy: ROUND_ROBIN
      circuit_breakers:
        thresholds:
          - priority: DEFAULT
            max_connections: 50
            max_pending_requests: 100
            max_requests: 60
      load_assignment:
        cluster_name: anthropic_api
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: api.anthropic.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: api.anthropic.com

layered_runtime:
  layers:
    - name: static_layer
      static_layer:
        envoy:
          resource_limits:
            listener:
              egress_https:
                connection_limit: 1000
